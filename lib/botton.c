/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>


#define AHB1RCC 0x40023800UL
#define AHB1ENR_OFFSET 0x30UL

#define AHB1ENR (AHB1RCC+AHB1ENR_OFFSET)

#define GPIOB_BASE_ODDR 0x40020400UL

#define GPIO_MODER_OFFSET 0x00UL
#define GPIO_MODER_ADDR (GPIOB_BASE_ODDR+GPIO_MODER_OFFSET)

#define GPIO_ODR_OFFSET 0x14UL
#define GPIO_ODR_ADDR (GPIOB_BASE_ODDR+GPIO_ODR_OFFSET)


int main(void)
{
	uint32_t *pAhbCrlReg = (uint32_t*) AHB1ENR;
	uint32_t *pGpioModeEnr = (uint32_t*) GPIO_MODER_ADDR;
	uint32_t *pGpio0ddEnr = (uint32_t*) GPIO_ODR_ADDR;


	//le pasamos al puntero con un OR a si miso con un "1" movido una posicion a la izquierda
	*pAhbCrlReg|=(1<<1);

//LED1
	//Hacemos AND con ...000011-> (3<<0) con el registro Mode para configurar el modo de memoria (necesita dos bit)
	// y lo negamos para poner los dos primeros bit (3--->11binaro) a 0 (lo machacamos) respetando el resto con el AND
	*pGpioModeEnr&=~(3<<0);
	//Lo ponemos el modo "01" que es salida pasando (1<<0)
	*pGpioModeEnr|=(1<<0);

	//Activamos la salida del PB0 a 1
	*pGpio0ddEnr|=(1<<0);

//LED2
	*pGpioModeEnr&=~(3<<14);
	*pGpioModeEnr|=(1<<14);
	*pGpio0ddEnr|=(1<<7);




    /* Loop forever */
	for(;;);
}
